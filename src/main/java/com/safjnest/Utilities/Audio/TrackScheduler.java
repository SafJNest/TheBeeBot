package com.safjnest.Utilities.Audio;

import com.sedmelluq.discord.lavaplayer.track.AudioTrack;
import com.sedmelluq.discord.lavaplayer.player.AudioPlayer;
import com.sedmelluq.discord.lavaplayer.tools.FriendlyException;
import com.sedmelluq.discord.lavaplayer.track.AudioTrackEndReason;
import com.sedmelluq.discord.lavaplayer.player.event.AudioEventAdapter;

import java.util.Collections;
import java.util.LinkedList;


/**
 * This class schedules tracks for the audio player.
 * It contains the queue, the events and the methods to handle them.
 * 
 * @author <a href="https://github.com/NeutronSun">NeutronSun</a>
 * @author <a href="https://github.com/Leon412">Leon412</a>
 * @since 1.0
 */
public class TrackScheduler extends AudioEventAdapter {

    /**
     * The queue of the scheduler.
     */
    private final LinkedList<AudioTrack> queue;
    
    /**
     * The unshuffled queue of the scheduler.
     * Its used to store the queue before shuffling.
     */
    private LinkedList<AudioTrack> unshuffledQueue;
    
    /**
     * Instance of the audio player.
     * Used to start, stop and pause tracks.
     * Generated by the {@link com.safjnest.Utilities.Audio.GuildMusicManager Guild Music Manager}.
     */
    private final AudioPlayer player;

    /**
     * The index of the current track in the queue.
     */
    private int currentTrackIndex;

    /**
     * If the queue is set to repeat.
     */
    private boolean isRepeat;

    /**
     * If the current track has been forced plays the previous one on trackEnd.
     */
    private boolean isForced;

    /**
     * If the player has been stopped.
     */
    private boolean isStopped;

    /**
     * If the queue is paused.
     */
    private boolean isQueuePaused;

    /**
     * Creates a new TrackScheduler.
     * 
     * @param player The audio player.
     */
    public TrackScheduler(AudioPlayer player) {
        this.player = player;
        this.queue = new LinkedList<>();
        
        this.currentTrackIndex = -1;
        this.unshuffledQueue = null;
        
        this.isRepeat = false;
        
        this.isForced = false;

        this.isStopped = false;
        this.isQueuePaused = false;
    }

    /**
     * Starts playing a track if there is no track playing.
     * @param track
     */
    public void play(AudioTrack track) {
        if(player.isPaused()) {
            player.setPaused(false);
        }
        isStopped = false;
        player.startTrack(track, true);
    }

    /**
     * Starts playing a track if there is no track playing.
     * @param track
     */
    public void play(AudioTrack track, long position) {
        if(player.isPaused()) {
            player.setPaused(false);
        }
        track.setPosition(position);
        play(track);
    }

    /**
     * Starts playing a track even if there is a track playing.
     * @param track
     */
    public void playForce(AudioTrack track, AudioType type) {
        isForced = (type == AudioType.SOUND);
        playForce(track);
    }

    /**
     * Starts playing a track even if there is a track playing.
     * @param track
     */
    public void playForce(AudioTrack track) {
        if(player.isPaused()) {
            player.setPaused(false);
        }

        player.startTrack(track, false);
    }




    /**
     * Starts playing a track even if there is a track playing.
     * @param track
     * @param position
     */
    public void playForce(AudioTrack track, long position) {
        track.setPosition(position);
        playForce(track);
    }

    /**
     * Adds a track to the queue and starts playing it if there is no track playing.
     * @param track
     * @see #play(AudioTrack)
     */
    public void queue(AudioTrack track) {
        queue.offer(track);
        if (currentTrackIndex == -1) {
            currentTrackIndex = queue.size() - 1;
        }
        play(getCurrentTrack());
    }

    /**
     * Adds a track to the queue without playing it.
     * @param track
     */
    public void queueNoPlay(AudioTrack track) {
        queue.offer(track);
    }

    /**
     * Adds a track to the front of the queue.
     * @param track
     */
    public void addTrackToFront(AudioTrack track) {
        if (currentTrackIndex < queue.size() - 1) {
            queue.add(currentTrackIndex + 1, track);
        } else {
            queue.offer(track);
        }
    }

    /**
     * Gets the current track without removing it from the queue.
     */
    public AudioTrack getCurrentTrack() {
        if (currentTrackIndex != -1 && currentTrackIndex < queue.size()) {
            return queue.get(currentTrackIndex).makeClone();
        }
        return null;
    }

    /**
     * Increases the current track index by one and returns the next track.
     */
    public AudioTrack nextTrack() {
        if (queue.isEmpty() || currentTrackIndex >= queue.size() - 1) {
            currentTrackIndex = -1;
            return null;
        }
        currentTrackIndex = currentTrackIndex + 1;
        return getCurrentTrack();
    }

    /**
     * Decreases the current track index by one and returns the previous track.
     */
    public AudioTrack prevTrack() {
        if (queue.isEmpty()) {
            return null;
        }

        if (currentTrackIndex == -1) {
            currentTrackIndex = queue.size() - 1;
        } else if (currentTrackIndex > 0) {
            currentTrackIndex--;
        } else {
            return null;
        }

        return getCurrentTrack();
    }

    /**
     * Starts playing the next track even if there is a track playing.
     */
    public void playForceNext() {
        playForce(nextTrack());
    }

    /**
     * Starts playing the previous track even if there is a track playing.
     */
    public void playForcePrev() {
        playForce(prevTrack());
    }

    public void clearQueue() {
        queue.clear();
        currentTrackIndex = -1;
        isForced = false;
        isRepeat = false;
    }

    @Override
    public void onPlayerPause(AudioPlayer player) {

    }

    @Override
    public void onPlayerResume(AudioPlayer player) {

    }

    @Override
    public void onTrackStart(AudioPlayer player, AudioTrack track) {

    }


    /**
     * This method handles all the events that are fired when a track ends.
     * <ul>
     * <li>{@code FINISHED}: A track finished or died by an exception (mayStartNext = true).</li>
     * <li>{@code LOAD_FAILED}: Loading of a track failed (mayStartNext = true).</li>
     * <li>{@code STOPPED}: The player was stopped.</li>
     * <li>{@code REPLACED}: Another track started playing while this had not finished.</li>
     * <li>{@code CLEANUP}: Player hasn't been queried for a while, if you want you can put a clone of this back to your queue.</li>
     * </ul>
     */
    @Override
    public void onTrackEnd(AudioPlayer player, AudioTrack track, AudioTrackEndReason endReason) {
        System.out.println(toString() + " [current: " + track.getInfo().title + "] [endReason: " + endReason + "]");
        if (endReason.mayStartNext) {
            if (isRepeat) {
                playForce(track.makeClone());
                return;
            }
            else if (isForced) {
                isForced = false;
                if (currentTrackIndex != -1 && !isQueuePaused && !isStopped) {
                    play(getCurrentTrack(), queue.get(currentTrackIndex).getPosition());
                }
                return;
            }

            play(nextTrack());
        } 

        if(endReason == AudioTrackEndReason.CLEANUP) {
            System.out.println("The time of thread has come to an end.");
        }

        if (endReason == AudioTrackEndReason.STOPPED) {
            isStopped = true;
        }

        if(endReason == AudioTrackEndReason.REPLACED) {
            if(isForced) {
                if (currentTrackIndex != -1 && !isQueuePaused && !isStopped) {
                    play(getCurrentTrack(), queue.get(currentTrackIndex).getPosition());
                }
            }
        }

        // endReason == FINISHED: A track finished or died by an exception (mayStartNext
        // = true).
        // endReason == LOAD_FAILED: Loading of a track failed (mayStartNext = true).
        // endReason == STOPPED: The player was stopped.
        // endReason == REPLACED: Another track started playing while this had not
        // finished
        // endReason == CLEANUP: Player hasn't been queried for a while, if you want you
        // can put a clone of this back to your queue
    }

    @Override
    public void onTrackException(AudioPlayer player, AudioTrack track, FriendlyException exception) {
        System.out.println("Track exception");
    }

    @Override
    public void onTrackStuck(AudioPlayer player, AudioTrack track, long thresholdMs) {
        System.out.println("Track stuck");
    }

    /**
     * @return true if the player is playing something, false otherwise.
     */
    public boolean isPlaying() {
        return // jda.getGuildById(guildId).getSelfMember().getVoiceState().inAudioChannel() &&
            player.getPlayingTrack() != null;
    }

    /**
     * @return true if the player is paused, false otherwise.
     */
    public boolean isPaused() {
        return player.isPaused();
    }

    /**
     * Return the {@link com.safjnest.Utilities.Audio.TrackScheduler#queue queue}
     * @return {@link java.util.LinkedList LinkedList}
     */
    public LinkedList<AudioTrack> getQueue() {
        return queue;
    }

    /**
     * Return the {@link com.safjnest.Utilities.Audio.TrackScheduler#currentTrackIndex currentTrackIndex}
     * @return int
     */
    public int getIndex() {
        return currentTrackIndex;
    }

    /**
     * Set the {@link com.safjnest.Utilities.Audio.TrackScheduler#currentTrackIndex currentTrackIndex}
     * @param index
     */
    public void setIndex(int index) {
        currentTrackIndex = index;
    }

    /**
     * Return the {@link com.safjnest.Utilities.Audio.TrackScheduler#player player}
     * @return {@link com.sedmelluq.discord.lavaplayer.player.AudioPlayer AudioPlayer}
     * @see com.sedmelluq.discord.lavaplayer.player.AudioPlayer
     */
    public AudioPlayer getPlayer() {
        return player;
    }

    /**
     * Shuffles the {@link com.safjnest.Utilities.Audio.TrackScheduler#queue queue}
     * @return boolean
     */
    public void shuffleQueue() {
        if (!queue.isEmpty()) {
            unshuffledQueue = new LinkedList<>(queue);
            Collections.shuffle(queue);

            if (currentTrackIndex != -1) {
                currentTrackIndex = queue.indexOf(unshuffledQueue.get(currentTrackIndex));
            }

        }
    }

    /**
     * Unshuffles the {@link com.safjnest.Utilities.Audio.TrackScheduler#queue queue}
     * switching it with the {@link com.safjnest.Utilities.Audio.TrackScheduler#unshuffledQueue unshuffledQueue}
     * @return boolean
     */
    public void unshuffleQueue() {
        if (unshuffledQueue != null) {
            if (currentTrackIndex != -1) {
                currentTrackIndex = unshuffledQueue.indexOf(queue.get(currentTrackIndex));
            }
            
            queue.clear();
            queue.addAll(unshuffledQueue);
            unshuffledQueue = null;
        }
    }

    public void setRepeat(boolean repeat) {
        isRepeat = repeat;
    }

    public boolean isRepeat() {
        return isRepeat;
    }

    public boolean isShuffled() {
        return unshuffledQueue != null;
    }

    public void pause(boolean pause) {
        TrackData data = player.getPlayingTrack().getUserData(TrackData.class);
        
        player.setPaused(pause);

        if (data != null && data.isQueueable()) {
            isQueuePaused = pause;
        }
    }

    public void stop() {
        player.stopTrack();
        currentTrackIndex++;
    }

    @Override
    public String toString() {
        return "TrackScheduler [currentTrackIndex=" + currentTrackIndex + ", isRepeat=" + isRepeat + ", isForced=" + isForced + ", isStopped=" + isStopped + ", isQueuePaused=" + isQueuePaused + "]";
    }

}